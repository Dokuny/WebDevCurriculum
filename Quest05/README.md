# Quest 05. OOP 특훈

## Introduction
* 이번 퀘스트에서는 바닐라 자바스크립트의 객체지향 프로그래밍을 조금 더 훈련해 보겠습니다.

## Topics
* Separation of Concerns
* 객체지향의 설계 원칙
  * SOLID 원칙
* Local Storage

## Resources
* [Separation of concerns](https://jonbellah.com/articles/separation-of-concerns/)
* [SOLID](https://en.wikipedia.org/wiki/SOLID)
* [객체지향 설계 5원칙](https://webdoli.tistory.com/210)
* [MDN - Local Storage](https://developer.mozilla.org/ko/docs/Web/API/Window/localStorage)

## Checklist
* 관심사의 분리 원칙이란 무엇인가요? 웹에서는 이러한 원칙이 어떻게 적용되나요?
  ```
    관심사 분리의 원칙(Separation of Concerns,SoC)
      * Solid 원칙 5개 중 2개(단일 책임 및 인터페이스 분리)가 이 개념에서 파생되었다.
      * 프로그램을 기능 면에서 가능한 중복이 아닌 여러 모듈로 명확히 나누는 것
      * 쉽게 말하자면, 프로그램을 작성할 때 하나의 단일블록으로 작성하지말고 잘개 쪼개서 관심사(=역할,기능,행동 등) 별로 작성하는 것
      * 더 쉽게 말하자면, 관심이 같다면 모으고, 관심이 다르면 분리시켜 서로에게 영향을 끼치지 않도록 하는 것
      
      * 관심사가 같은 것끼리는 하나의 객체 또는 친한 객체로 모은다.
      * 관심사가 다른 것은 가능한 한 따로 떨어져 서로 영향을 주지 않도록 분리한다.
      * 하나의 속성, 메소드, 클래스, 모듈, 패키지에는 하나의 관심사만 들어있어야 한다
  
      * 웹에서는 HTML과 CSS를 분리시키고(전처리기 사용),CSS와 자바스크립트를 분리(클래스나 아이디로 자바스크립트와 연관되어있다는 것을 표시)한다.
  ```
  * 객체지향의 SOLID 원칙이란 무엇인가요? 이 원칙을 구체적인 예를 들어 설명할 수 있나요?
    ```
    SOLID 원칙 : 
    
      SRP(단일 책임 원칙,Single Responsibility Principle) : 어떤 클래스를 변경해야 하는 이유는 오직 하나여야 한다.
                           메소드가 단일 책임 원칙을 지키지 않을 경우 나타나는 대표적인 예가 분기 처리를 위한 if문이다.

      OCP(개방 폐쇄 원칙,Open Closed Principle) : 클래스, 모듈, 함수 등은 확장에 대해서 열려있어야 하지만 변경에 대해서는 닫혀 있어야 한다.

      LSP(리스코프 치환 원칙,Liskov Substitution Principle) : 서브 타입은 언제나 자신의 기반(상위) 타입으로 교체 가능해야 한다.
                                                            (서브 타입이란 하위클래스,하위객체,구현클래스 등을 의미)
                                                             하위 클래스의 인스턴스는 상위 타입 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는데 문제가 없어야 한다

      ISP(인터페이스 분리 원칙,Interface Segregation Principle) : 클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안된다.

      DIP(의존 역전 법칙,Dependency Inversion Principle) : 자신보다 변하기 쉬운 것에 의존하지 마라.
                                                          고차원 모듈은 저차원 모듈에 의존하면 안된다. 이 두 모듈 모두 다른 추상화된 것에 의존해야 한다.
                                                          추상화된 것은 구체화된 것에 의존하면 안된다. 구체적인 것이 추상화된 것에 의존해야 한다.
    ```
  
* 로컬 스토리지란 무엇인가요? 로컬 스토리지의 내용을 개발자 도구를 이용해 확인하려면 어떻게 해야 할까요?
  ```
  * 브라우저 상에 데이터를 저장할 수 있는 기술인 웹 스토리지 중 하나(로컬스토리지와 세션스토리지)
  * 세션 스토리지는 웹페이지의 세션이 끝날 때 저장된 데이터가 지워지는 반면에, 로컬 스토리지는 웹페이지의 세션이 끝나더라도 데이터가 지워지지 않는다
  * 브라우저에서 같은 웹사이트를 여러 탭이나 창에 띄우면, 여러 개의 세션 스토리지에 데이터가 서로 격리되어 저장되며, 각 탭이나 창이 닫힐 때 저장해 둔 데이터도 함께 소멸한다 
  * 반면에, 로컬 스토리지의 경우 여러 탭이나 창 간에 데이터가 서로 공유되며 탭이나 창을 닫아도 데이터는 브라우저에 그대로 남아 있다.
  * 로컬 스토리지의 데이터 영속성(persistence)은 어디까지나 계속해서 동일한 컴퓨터에서 동일한 브라우저를 사용할 때만 해당한다.
  * 로컬 스토리지와 세션 스토리지의 공통점은 모두 데이터를 브라우저 상에 저장한다는 것이며, 자바스크립트 API가 완전히 동일한 형태이다.
  ```
  ```javascript
  // 기본 API(세션스토리지는 sessionStorage로 교체만 하면된다,window로 접근해야하지만 생략가능)
  // 키와 값 형태로 저장한다.
  
  // 키에 데이터 쓰기
  localStorage.setItem("key", value);

  // 키로 부터 데이터 읽기
  localStorage.getItem("key");

  // 키의 데이터 삭제
  localStorage.removeItem("key");

  // 모든 키의 데이터 삭제
  localStorage.clear();

  // 저장된 키/값 쌍의 개수
  localStorage.length;
  
  // 주의사항
  // 오직 문자형 데이터 타입만 지원한다.
  // 그렇기 때문에 JSON 형태로 읽고 써야한다.
   localStorage.setItem('json', JSON.stringify({a: 1, b: 2}))
   // undefined
   JSON.parse(localStorage.getItem('json'))
   // {a: 1, b: 2}
  
  // 로컬 스토리지에 저장된 데이터는 웹페이지를 닫는다고 해서 사리지지 않으므로 불필요한 데이터가 남지않도록 clear나 removeItem으로 지워주자.
  // 크롬의 경우 Application 탭에 들어가면 왼편에 Storage 영역에서 웹 스토리지에 어떤 데이터가 저장되어있는지를 쉽게 확인하고 삭제할 수 있다.
  ```


## Quest
* 외부 라이브러리나 프레임워크를 사용하지 않고, 자바스크립트를 이용하여 간단한 웹브라우저 기반의 텍스트 에디터를 만들어 보겠습니다.
  * 기본적으로VSCode와 같이 탭을 이용해 여러 개의 파일을 동시에 편집할 수 있습니다.
  * 탭을 눌러 열려 있는 다른 파일을 편집할 수 있으며 탭을 언제든지 닫을 수 있습니다.
  * VSCode와 같이 새 파일, 로드, 저장, 다른 이름으로 저장 등의 기능을 가집니다. 저장은 웹 브라우저의 로컬 스토리지를 이용합니다.
  * VSCode와 같이 탭이 수정되었 는데 저장되기 이전일 경우 이를 알려주는 인디케이터가 작동합니다.
  * 같은 이름의 파일을 저장할 경우 에러를 표시해야 합니다.
* 이번 퀘스트의 결과물은 앞으로의 많은 퀘스트에서 재사용되게 되니, 주의깊게 코드를 작성해 보세요!

## Advanced
* 웹 프론트엔드 개발에서 이러한 방식의 패턴을 더 일반화해서 정리할 수 있을까요? 이 퀘스트에서 각각의 클래스들이 공통적으로 수행하게 되는 일들에는 무엇이 있을까요?
